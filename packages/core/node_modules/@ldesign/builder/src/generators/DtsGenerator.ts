/**
 * TypeScript 声明文件生成器
 *
 * 使用 TypeScript Compiler API 直接生成 d.ts 文件
 * 不依赖 rollup-plugin-dts 或其他插件，避免版本兼容问题
 *
 * 功能特性：
 * - 自动重试机制
 * - 增量编译支持
 * - 生成文件验证
 * - 详细的错误处理
 *
 * @author LDesign Team
 * @version 2.0.0
 */

import * as ts from 'typescript'
import * as path from 'path'
import * as fs from 'node:fs'
import * as fse from 'fs-extra'
import { glob } from 'glob'
import type { Logger } from '../utils/logger'
import { createLogger } from '../utils/logger'

/**
 * DTS 生成选项
 */
export interface DtsGeneratorOptions {
  /** 源码目录 */
  srcDir: string
  /** 输出目录 */
  outDir: string
  /** tsconfig 文件路径 */
  tsconfig?: string
  /** 是否保持源码目录结构 */
  preserveStructure?: boolean
  /** 是否生成 declarationMap */
  declarationMap?: boolean
  /** 项目根目录 */
  rootDir?: string
  /** 要处理的文件模式 */
  include?: string[]
  /** 要排除的文件模式 */
  exclude?: string[]
  /** 日志记录器 */
  logger?: Logger
  /** 最大重试次数（默认 3） */
  maxRetries?: number
  /** 重试延迟（毫秒，默认 1000） */
  retryDelay?: number
  /** 是否启用增量生成（默认 true） */
  incremental?: boolean
  /** 是否验证生成的文件（默认 true） */
  validate?: boolean
  /** 失败时是否继续（默认 true） */
  continueOnError?: boolean
}

/**
 * 生成结果
 */
export interface DtsGenerationResult {
  /** 是否成功 */
  success: boolean
  /** 生成的文件列表 */
  files: string[]
  /** 错误信息 */
  errors?: string[]
  /** 警告信息 */
  warnings?: string[]
  /** 耗时（毫秒） */
  duration: number
  /** 重试次数 */
  retries?: number
  /** 跳过的文件 */
  skipped?: string[]
  /** 验证结果 */
  validation?: {
    valid: boolean
    issues: string[]
  }
}

/**
 * TypeScript 声明文件生成器
 *
 * @example
 * ```typescript
 * const generator = new DtsGenerator({
 *   srcDir: 'src',
 *   outDir: 'dist/types',
 *   incremental: true,
 *   maxRetries: 3
 * })
 * const result = await generator.generate()
 * ```
 */
export class DtsGenerator {
  private logger: Logger
  private options: Required<DtsGeneratorOptions>

  /**
   * 创建 DTS 生成器实例
   *
   * @param options - 生成器配置选项
   */
  constructor(options: DtsGeneratorOptions) {
    this.logger = options.logger || createLogger()
    this.options = {
      srcDir: options.srcDir,
      outDir: options.outDir,
      tsconfig: options.tsconfig || path.join(process.cwd(), 'tsconfig.json'),
      preserveStructure: options.preserveStructure ?? true,
      declarationMap: options.declarationMap ?? false,
      rootDir: options.rootDir || process.cwd(),
      include: options.include || ['**/*.ts', '**/*.tsx', '**/*.vue'],
      exclude: options.exclude || ['**/*.test.ts', '**/*.spec.ts', '**/__tests__/**', '**/node_modules/**'],
      logger: this.logger,
      maxRetries: options.maxRetries ?? 3,
      retryDelay: options.retryDelay ?? 1000,
      incremental: options.incremental ?? true,
      validate: options.validate ?? true,
      continueOnError: options.continueOnError ?? true,
    }
  }

  /**
   * 生成声明文件（带重试机制）
   *
   * @returns 生成结果
   */
  async generate(): Promise<DtsGenerationResult> {
    let lastError: Error | null = null
    let retries = 0

    for (let attempt = 0; attempt <= this.options.maxRetries; attempt++) {
      try {
        const result = await this.doGenerate()

        // 验证生成的文件
        if (this.options.validate && result.success) {
          const validation = await this.validateGeneratedFiles(result.files)
          return { ...result, retries, validation }
        }

        return { ...result, retries }
      }
      catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error))
        retries = attempt

        if (attempt < this.options.maxRetries) {
          this.logger.warn(`DTS 生成失败，${this.options.retryDelay}ms 后重试 (${attempt + 1}/${this.options.maxRetries})`)
          await this.delay(this.options.retryDelay)
        }
      }
    }

    // 所有重试都失败
    return {
      success: false,
      files: [],
      errors: [lastError?.message || '未知错误'],
      duration: 0,
      retries,
    }
  }

  /**
   * 实际生成逻辑
   */
  private async doGenerate(): Promise<DtsGenerationResult> {
    const startTime = Date.now()
    const generatedFiles: string[] = []
    const skippedFiles: string[] = []
    const errors: string[] = []
    const warnings: string[] = []

    this.logger.debug('开始生成 TypeScript 声明文件...')
    this.logger.debug(`源码目录: ${this.options.srcDir}`)
    this.logger.debug(`输出目录: ${this.options.outDir}`)

    // 确保输出目录存在
    await fse.ensureDir(this.options.outDir)

    // 读取并解析 tsconfig
    const tsconfig = await this.loadTsConfig()

    // 获取要处理的文件列表
    const allFiles = await this.getSourceFiles()
    this.logger.debug(`找到 ${allFiles.length} 个源文件`)

    if (allFiles.length === 0) {
      this.logger.warn('没有找到需要处理的 TypeScript 文件')
      return {
        success: true,
        files: [],
        warnings: ['没有找到需要处理的 TypeScript 文件'],
        duration: Date.now() - startTime,
        retries: 0,
      }
    }

    // 检查增量编译缓存
    const files = this.options.incremental
      ? await this.filterChangedFiles(allFiles)
      : allFiles

    if (files.length === 0) {
      this.logger.info('✅ 所有文件都是最新的，无需重新生成')
      return {
        success: true,
        files: [],
        duration: Date.now() - startTime,
        retries: 0,
      }
    }

    this.logger.debug(`需要处理 ${files.length} 个文件`)

    // 创建编译器配置
    const compilerOptions = this.createCompilerOptions(tsconfig)

    // 创建编译器主机
    const host = this.createCompilerHost(compilerOptions)

    // 创建程序
    const program = ts.createProgram({
      rootNames: files,
      options: compilerOptions,
      host,
    })

    // 获取诊断信息
    const diagnostics = ts.getPreEmitDiagnostics(program)
    const filteredDiagnostics = this.filterDiagnostics(diagnostics)

    // 记录诊断信息
    for (const diagnostic of filteredDiagnostics) {
      const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')
      if (diagnostic.category === ts.DiagnosticCategory.Error) {
        if (this.options.continueOnError) {
          warnings.push(`[跳过] ${message}`)
          if (diagnostic.file) {
            skippedFiles.push(diagnostic.file.fileName)
          }
        }
        else {
          errors.push(message)
        }
      }
      else {
        warnings.push(message)
      }
    }

    // 如果有严重错误且不允许继续，则抛出
    if (errors.length > 0 && !this.options.continueOnError) {
      throw new Error(`TypeScript 编译错误:\n${errors.join('\n')}`)
    }

    // 生成声明文件
    const emitResult = program.emit(
      undefined,
      (fileName, data) => {
        if (fileName.endsWith('.d.ts') || fileName.endsWith('.d.ts.map')) {
          const relativePath = path.relative(compilerOptions.outDir!, fileName)
          const targetPath = path.join(this.options.outDir, relativePath)

          fse.ensureDirSync(path.dirname(targetPath))
          fs.writeFileSync(targetPath, data, 'utf-8')

          if (fileName.endsWith('.d.ts')) {
            generatedFiles.push(targetPath)
            this.logger.debug(`生成: ${relativePath}`)
          }
        }
      },
      undefined,
      true,
      undefined,
    )

    // 处理生成错误
    if (emitResult.emitSkipped && generatedFiles.length === 0) {
      throw new Error('声明文件生成被跳过')
    }

    // 更新增量编译缓存
    if (this.options.incremental) {
      await this.updateFileCache(files)
    }

    const duration = Date.now() - startTime
    this.logger.info(`✅ 生成了 ${generatedFiles.length} 个声明文件 (${duration}ms)`)

    return {
      success: true,
      files: generatedFiles,
      skipped: skippedFiles.length > 0 ? skippedFiles : undefined,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined,
      duration,
      retries: 0,
    }
  }

  /**
   * 过滤诊断信息
   */
  private filterDiagnostics(diagnostics: readonly ts.Diagnostic[]): ts.Diagnostic[] {
    return diagnostics.filter((diagnostic) => {
      const code = diagnostic.code
      const file = diagnostic.file?.fileName || ''

      // 忽略 .vue 文件相关的错误
      if (file.endsWith('.vue') || file.includes('.vue')) {
        return false
      }

      // 忽略特定的错误码
      const ignoredCodes = [
        2688, // Cannot find type definition file
        2307, // Cannot find module
        5096, // Option conflicts
        6133, // Unused variable
        7016, // Could not find declaration file
        2304, // Cannot find name
        2339, // Property does not exist
        2345, // Argument type mismatch
        2322, // Type is not assignable
        1259, // Module can only be default-imported
        1192, // Module has no default export
      ]

      return !ignoredCodes.includes(code)
    })
  }

  /**
   * 加载 tsconfig
   */
  private async loadTsConfig(): Promise<ts.ParsedCommandLine> {
    const configPath = this.options.tsconfig

    if (!await fse.pathExists(configPath)) {
      this.logger.debug(`tsconfig 不存在: ${configPath}，使用默认配置`)
      return this.getDefaultTsConfig()
    }

    const configFile = ts.readConfigFile(configPath, ts.sys.readFile)

    if (configFile.error) {
      this.logger.warn(`读取 tsconfig 失败，使用默认配置`)
      return this.getDefaultTsConfig()
    }

    return ts.parseJsonConfigFileContent(
      configFile.config,
      ts.sys,
      path.dirname(configPath),
    )
  }

  /**
   * 获取默认 tsconfig
   */
  private getDefaultTsConfig(): ts.ParsedCommandLine {
    return {
      options: {
        target: ts.ScriptTarget.ES2020,
        module: ts.ModuleKind.ESNext,
        lib: ['lib.es2020.d.ts', 'lib.dom.d.ts'],
        moduleResolution: ts.ModuleResolutionKind.Bundler,
        esModuleInterop: true,
        skipLibCheck: true,
        strict: true,
      },
      fileNames: [],
      errors: [],
    }
  }

  /**
   * 创建编译器选项
   */
  private createCompilerOptions(tsconfig: ts.ParsedCommandLine): ts.CompilerOptions {
    const baseOptions = tsconfig.options || {}

    return {
      ...baseOptions,
      declaration: true,
      declarationMap: this.options.declarationMap,
      emitDeclarationOnly: true,
      outDir: this.options.outDir,
      rootDir: this.options.preserveStructure ? this.options.srcDir : undefined,
      skipLibCheck: true,
      skipDefaultLibCheck: true,
      noEmit: false,
      allowJs: false,
      moduleResolution: baseOptions.moduleResolution || ts.ModuleResolutionKind.Bundler,
      noUnusedLocals: false,
      noUnusedParameters: false,
      allowSyntheticDefaultImports: true,
      esModuleInterop: true,
      resolveJsonModule: true,
      isolatedModules: false,
      incremental: this.options.incremental,
      tsBuildInfoFile: this.options.incremental
        ? path.join(this.options.outDir, '.tsbuildinfo')
        : undefined,
    }
  }

  /**
   * 创建编译器主机
   */
  private createCompilerHost(options: ts.CompilerOptions): ts.CompilerHost {
    const host = ts.createCompilerHost(options)

    const originalWriteFile = host.writeFile
    if (originalWriteFile) {
      host.writeFile = (fileName, data, writeByteOrderMark, onError, sourceFiles) => {
        if (this.options.preserveStructure) {
          const relativePath = path.relative(
            options.rootDir || this.options.srcDir,
            fileName,
          )
          const targetPath = path.join(this.options.outDir, relativePath)
          fileName = targetPath
        }

        originalWriteFile(fileName, data, writeByteOrderMark, onError, sourceFiles)
      }
    }

    return host
  }

  /**
   * 获取源文件列表
   */
  private async getSourceFiles(): Promise<string[]> {
    const patterns = this.options.include.map(pattern =>
      path.join(this.options.srcDir, pattern).replace(/\\/g, '/'),
    )

    const excludePatterns = this.options.exclude.map(pattern =>
      path.join(this.options.srcDir, pattern).replace(/\\/g, '/'),
    )

    const files: string[] = []

    for (const pattern of patterns) {
      const matches = await glob(pattern, {
        ignore: excludePatterns,
        absolute: true,
        nodir: true,
      })

      const tsFiles = matches.filter((file) => {
        const ext = path.extname(file)
        return ext === '.ts' || ext === '.tsx'
      })

      files.push(...tsFiles)
    }

    return Array.from(new Set(files))
  }

  /**
   * 过滤已更改的文件（增量编译）
   */
  private async filterChangedFiles(files: string[]): Promise<string[]> {
    const cacheFile = path.join(this.options.outDir, '.dts-cache.json')

    if (!await fse.pathExists(cacheFile)) {
      return files
    }

    try {
      const cache = await fse.readJson(cacheFile)
      const changedFiles: string[] = []

      for (const file of files) {
        const stat = await fse.stat(file)
        const mtime = stat.mtimeMs

        if (!cache[file] || cache[file] !== mtime) {
          changedFiles.push(file)
        }
      }

      return changedFiles
    }
    catch {
      return files
    }
  }

  /**
   * 更新文件缓存
   */
  private async updateFileCache(files: string[]): Promise<void> {
    const cacheFile = path.join(this.options.outDir, '.dts-cache.json')
    const cache: Record<string, number> = {}

    try {
      if (await fse.pathExists(cacheFile)) {
        Object.assign(cache, await fse.readJson(cacheFile))
      }

      for (const file of files) {
        const stat = await fse.stat(file)
        cache[file] = stat.mtimeMs
      }

      await fse.writeJson(cacheFile, cache, { spaces: 2 })
    }
    catch (error) {
      this.logger.debug('更新缓存失败:', error)
    }
  }

  /**
   * 验证生成的文件
   */
  private async validateGeneratedFiles(files: string[]): Promise<{ valid: boolean, issues: string[] }> {
    const issues: string[] = []

    for (const file of files) {
      try {
        if (!await fse.pathExists(file)) {
          issues.push(`文件不存在: ${file}`)
          continue
        }

        const content = await fse.readFile(file, 'utf-8')

        if (content.trim().length === 0) {
          issues.push(`文件为空: ${file}`)
          continue
        }

        if (!content.includes('export') && !content.includes('declare')) {
          issues.push(`文件可能无效（无导出或声明）: ${file}`)
        }
      }
      catch (error) {
        issues.push(`验证失败: ${file} - ${error}`)
      }
    }

    return {
      valid: issues.length === 0,
      issues,
    }
  }

  /**
   * 延迟函数
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  /**
   * 清理输出目录
   */
  async clean(): Promise<void> {
    try {
      if (await fse.pathExists(this.options.outDir)) {
        this.logger.debug(`清理输出目录: ${this.options.outDir}`)
        await fse.emptyDir(this.options.outDir)
      }
    }
    catch (error) {
      this.logger.warn(`清理输出目录失败:`, error)
    }
  }
}

/**
 * 创建 DTS 生成器
 */
export function createDtsGenerator(options: DtsGeneratorOptions): DtsGenerator {
  return new DtsGenerator(options)
}

/**
 * 快捷生成函数
 */
export async function generateDts(options: DtsGeneratorOptions): Promise<DtsGenerationResult> {
  const generator = createDtsGenerator(options)
  return await generator.generate()
}

/**
 * 快捷生成函数（带重试）
 *
 * @deprecated 使用 generateDts 代替，已内置重试机制
 */
export async function generateDtsWithRetry(options: DtsGeneratorOptions): Promise<DtsGenerationResult> {
  return generateDts(options)
}
