/**
 * Package.json è‡ªåŠ¨æ›´æ–°å·¥å…·
 *
 * è´Ÿè´£åœ¨æ„å»ºå®Œæˆåè‡ªåŠ¨æ›´æ–° package.json çš„ exportsã€mainã€moduleã€typesã€files ç­‰å­—æ®µ
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - è‡ªåŠ¨ç”Ÿæˆ exports é…ç½®
 * - æ¡ä»¶å¯¼å‡ºæ”¯æŒï¼ˆnode/browser/defaultï¼‰
 * - å¹³å°ç‰¹å®šå…¥å£ç‚¹
 * - æ™ºèƒ½ CSS æ–‡ä»¶å¯¼å‡º
 * - sideEffects å­—æ®µç®¡ç†
 *
 * @author LDesign Team
 * @version 2.0.0
 */

import { promises as fs, existsSync } from 'node:fs'
import path from 'node:path'
import type { Logger } from '../logger'
import { createLogger } from '../logger'

/**
 * å¹³å°ç±»å‹
 */
export type Platform = 'node' | 'browser' | 'universal'

/**
 * æ¡ä»¶å¯¼å‡ºé…ç½®
 */
export interface ConditionalExportConfig {
  /** ç›®æ ‡å¹³å° */
  platform: Platform
  /** æ˜¯å¦å¯ç”¨ development/production æ¡ä»¶ */
  enableDevProd?: boolean
  /** Node.js ç‰¹å®šå…¥å£ï¼ˆä»… platform ä¸º node æˆ– universal æ—¶æœ‰æ•ˆï¼‰ */
  nodeEntry?: string
  /** æµè§ˆå™¨ç‰¹å®šå…¥å£ï¼ˆä»… platform ä¸º browser æˆ– universal æ—¶æœ‰æ•ˆï¼‰ */
  browserEntry?: string
  /** æ˜¯å¦ç”Ÿæˆ default æ¡ä»¶ */
  includeDefault?: boolean
}

/**
 * Package.json æ›´æ–°é…ç½®
 */
export interface PackageUpdaterConfig {
  /** é¡¹ç›®æ ¹ç›®å½• */
  projectRoot: string
  /** æºç ç›®å½•ï¼Œé»˜è®¤ä¸º 'src' */
  srcDir?: string
  /** è¾“å‡ºç›®å½•é…ç½® */
  outputDirs?: {
    /** ESM è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ä¸º 'es' */
    esm?: string
    /** CJS è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ä¸º 'lib' */
    cjs?: string
    /** UMD è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ä¸º 'dist' */
    umd?: string
    /** ç±»å‹å£°æ˜ç›®å½•ï¼Œé»˜è®¤ä¸º 'es' */
    types?: string
    /** Node.js ç‰¹å®šè¾“å‡ºç›®å½• */
    node?: string
    /** æµè§ˆå™¨ç‰¹å®šè¾“å‡ºç›®å½• */
    browser?: string
  }
  /** æ¡ä»¶å¯¼å‡ºé…ç½® */
  conditionalExports?: ConditionalExportConfig
  /** æ˜¯å¦å¯ç”¨è‡ªåŠ¨ exports ç”Ÿæˆ */
  autoExports?: boolean
  /** æ˜¯å¦æ›´æ–° main/module/types å­—æ®µ */
  updateEntryPoints?: boolean
  /** æ˜¯å¦æ›´æ–° files å­—æ®µ */
  updateFiles?: boolean
  /** è‡ªå®šä¹‰ exports é…ç½® */
  customExports?: Record<string, any>
  /** æ—¥å¿—è®°å½•å™¨ */
  logger?: Logger
  /** æ˜¯å¦å¯ç”¨ sideEffects å­—æ®µæ›´æ–° */
  updateSideEffects?: boolean
  /** sideEffects é…ç½® */
  sideEffects?: boolean | string[]
}

/**
 * å¯¼å‡ºæ¡ç›®ç±»å‹
 */
interface ExportEntry {
  types?: string
  node?: string | { import?: string, require?: string }
  browser?: string | { import?: string, require?: string }
  import?: string
  require?: string
  default?: string
}

/**
 * Package.json æ›´æ–°å™¨
 *
 * @example
 * ```typescript
 * const updater = new PackageUpdater({
 *   projectRoot: process.cwd(),
 *   conditionalExports: {
 *     platform: 'universal',
 *     includeDefault: true
 *   }
 * })
 * await updater.update()
 * ```
 */
export class PackageUpdater {
  private config: Required<PackageUpdaterConfig>
  private logger: Logger

  constructor(config: PackageUpdaterConfig) {
    this.logger = config.logger || createLogger({ prefix: 'PackageUpdater' })
    this.config = {
      projectRoot: config.projectRoot,
      srcDir: config.srcDir || 'src',
      outputDirs: {
        esm: 'es',
        cjs: 'lib',
        umd: 'dist',
        types: 'es',
        node: undefined,
        browser: undefined,
        ...config.outputDirs,
      },
      conditionalExports: {
        platform: 'universal',
        enableDevProd: false,
        includeDefault: true,
        ...config.conditionalExports,
      },
      autoExports: config.autoExports ?? true,
      updateEntryPoints: config.updateEntryPoints ?? true,
      updateFiles: config.updateFiles ?? true,
      customExports: config.customExports || {},
      logger: this.logger,
      updateSideEffects: config.updateSideEffects ?? true,
      sideEffects: config.sideEffects ?? false,
    }
  }

  /**
   * æ‰§è¡Œ package.json æ›´æ–°
   */
  async update(): Promise<void> {
    try {
      this.logger.info('ğŸ”§ å¼€å§‹æ›´æ–° package.json...')

      const packageJsonPath = path.join(this.config.projectRoot, 'package.json')
      const packageJson = await this.readPackageJson(packageJsonPath)

      // ç”Ÿæˆ exports
      if (this.config.autoExports) {
        packageJson.exports = await this.generateExports()
        this.logger.debug(`ç”Ÿæˆäº† ${Object.keys(packageJson.exports).length} ä¸ªå¯¼å‡ºæ¡ç›®`)
      }

      // æ›´æ–°å…¥å£ç‚¹
      if (this.config.updateEntryPoints) {
        this.updateEntryPoints(packageJson)
      }

      // æ›´æ–° files å­—æ®µ
      if (this.config.updateFiles) {
        packageJson.files = await this.generateFiles()
      }

      // æ›´æ–° sideEffects
      if (this.config.updateSideEffects) {
        packageJson.sideEffects = this.config.sideEffects
      }

      // ç¡®ä¿ type: "module"
      if (!packageJson.type) {
        packageJson.type = 'module'
      }

      // æ’åºå­—æ®µ
      const sortedPackageJson = this.sortPackageJsonFields(packageJson)

      await this.writePackageJson(packageJsonPath, sortedPackageJson)
      this.logger.success('âœ… package.json æ›´æ–°å®Œæˆ')
    }
    catch (error) {
      this.logger.error('package.json æ›´æ–°å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * ç”Ÿæˆ exports é…ç½®
   */
  private async generateExports(): Promise<Record<string, any>> {
    const srcPath = path.join(this.config.projectRoot, this.config.srcDir)
    const exports: Record<string, any> = {}

    // ä¸»å…¥å£
    exports['.'] = this.createConditionalExportEntry('index')

    // æ‰«æ src ä¸‹çš„ç›´æ¥å­ç›®å½•
    const directories = await this.scanDirectDirectories(srcPath)

    for (const dir of directories) {
      const dirName = path.basename(dir)

      // æ£€æŸ¥æ˜¯å¦æœ‰ TypeScript æ–‡ä»¶
      if (await this.hasTypeScriptFiles(dir)) {
        // æ£€æŸ¥æ˜¯å¦æœ‰ index æ–‡ä»¶
        if (await this.hasIndexFile(dir)) {
          exports[`./${dirName}`] = this.createConditionalExportEntry(`${dirName}/index`)
        }

        // æ”¯æŒé€šé…ç¬¦å¯¼å…¥
        exports[`./${dirName}/*`] = this.createWildcardExportEntry(dirName)
      }
    }

    // æ·»åŠ  CSS å¯¼å‡º
    await this.addCssExports(exports)

    // æ·»åŠ  package.json å¯¼å‡ºï¼ˆç”¨äºå·¥å…·è¯»å–ï¼‰
    exports['./package.json'] = './package.json'

    // åˆå¹¶è‡ªå®šä¹‰ exports
    return { ...exports, ...this.config.customExports }
  }

  /**
   * åˆ›å»ºæ¡ä»¶å¯¼å‡ºæ¡ç›®
   */
  private createConditionalExportEntry(relativePath: string): ExportEntry {
    const { esm, cjs, types, node, browser } = this.config.outputDirs
    const { platform, includeDefault } = this.config.conditionalExports
    const entry: ExportEntry = {}

    // ç±»å‹å£°æ˜ï¼ˆå§‹ç»ˆæ”¾åœ¨æœ€å‰é¢ï¼‰
    if (types) {
      entry.types = `./${types}/${relativePath}.d.ts`
    }

    // æ ¹æ®å¹³å°ç”Ÿæˆæ¡ä»¶å¯¼å‡º
    if (platform === 'node' || platform === 'universal') {
      if (node) {
        entry.node = {
          import: `./${node}/${relativePath}.js`,
          require: `./${node}/${relativePath}.cjs`,
        }
      }
      else if (platform === 'node') {
        if (esm) entry.import = `./${esm}/${relativePath}.js`
        if (cjs) entry.require = `./${cjs}/${relativePath}.cjs`
      }
    }

    if (platform === 'browser' || platform === 'universal') {
      if (browser) {
        entry.browser = {
          import: `./${browser}/${relativePath}.js`,
          require: `./${browser}/${relativePath}.cjs`,
        }
      }
      else if (platform === 'browser') {
        if (esm) entry.import = `./${esm}/${relativePath}.js`
        if (cjs) entry.require = `./${cjs}/${relativePath}.cjs`
      }
    }

    // universal å¹³å°ä¸”æ²¡æœ‰ä¸“é—¨ç›®å½•æ—¶ï¼Œä½¿ç”¨æ ‡å‡†å¯¼å‡º
    if (platform === 'universal' && !node && !browser) {
      if (esm) entry.import = `./${esm}/${relativePath}.js`
      if (cjs) entry.require = `./${cjs}/${relativePath}.cjs`
    }

    // æ·»åŠ  default æ¡ä»¶
    if (includeDefault && esm) {
      entry.default = `./${esm}/${relativePath}.js`
    }

    return entry
  }

  /**
   * åˆ›å»ºé€šé…ç¬¦å¯¼å‡ºæ¡ç›®
   */
  private createWildcardExportEntry(dirName: string): ExportEntry {
    const { esm, cjs, types } = this.config.outputDirs
    const { includeDefault } = this.config.conditionalExports
    const entry: ExportEntry = {}

    if (types) {
      entry.types = `./${types}/${dirName}/*.d.ts`
    }

    if (esm) {
      entry.import = `./${esm}/${dirName}/*.js`
    }

    if (cjs) {
      entry.require = `./${cjs}/${dirName}/*.cjs`
    }

    if (includeDefault && esm) {
      entry.default = `./${esm}/${dirName}/*.js`
    }

    return entry
  }

  /**
   * æ‰«æç›´æ¥å­ç›®å½•
   */
  private async scanDirectDirectories(srcPath: string): Promise<string[]> {
    try {
      const entries = await fs.readdir(srcPath, { withFileTypes: true })
      const directories: string[] = []

      for (const entry of entries) {
        if (entry.isDirectory() && !entry.name.startsWith('.') && !entry.name.startsWith('_')) {
          directories.push(path.join(srcPath, entry.name))
        }
      }

      return directories
    }
    catch {
      return []
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰ index æ–‡ä»¶
   */
  private async hasIndexFile(dir: string): Promise<boolean> {
    const indexFiles = ['index.ts', 'index.tsx', 'index.js', 'index.vue']

    for (const file of indexFiles) {
      try {
        await fs.access(path.join(dir, file))
        return true
      }
      catch {
        // ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ª
      }
    }

    return false
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰ TypeScript æ–‡ä»¶
   */
  private async hasTypeScriptFiles(dir: string): Promise<boolean> {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true })

      for (const entry of entries) {
        if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {
          return true
        }
      }

      return false
    }
    catch {
      return false
    }
  }

  /**
   * æ›´æ–°å…¥å£ç‚¹å­—æ®µ
   */
  private updateEntryPoints(packageJson: any): void {
    const { esm, cjs, umd, types, node, browser } = this.config.outputDirs
    const { platform } = this.config.conditionalExports

    // ä¸»å…¥å£ç‚¹ - CJS æ ¼å¼
    if (cjs) {
      packageJson.main = `./${cjs}/index.cjs`
    }

    // ESM å…¥å£ç‚¹
    if (esm) {
      packageJson.module = `./${esm}/index.js`
    }

    // TypeScript ç±»å‹å®šä¹‰
    if (types) {
      packageJson.types = `./${types}/index.d.ts`
      packageJson.typings = `./${types}/index.d.ts`
    }

    // æµè§ˆå™¨å…¥å£ç‚¹
    if (platform === 'browser' || platform === 'universal') {
      if (browser) {
        packageJson.browser = `./${browser}/index.js`
      }
      else if (umd) {
        packageJson.browser = `./${umd}/index.js`
      }
    }

    // UMD æ ¼å¼ - ç”¨äº CDN
    if (umd) {
      const minifiedPath = `./${umd}/index.min.js`
      const regularPath = `./${umd}/index.js`
      const minifiedFullPath = path.join(this.config.projectRoot, umd, 'index.min.js')

      if (this.fileExistsSync(minifiedFullPath)) {
        packageJson.unpkg = minifiedPath
        packageJson.jsdelivr = minifiedPath
      }
      else {
        packageJson.unpkg = regularPath
        packageJson.jsdelivr = regularPath
      }
    }
  }

  /**
   * ç”Ÿæˆ files å­—æ®µ
   */
  private async generateFiles(): Promise<string[]> {
    const files = new Set(['README.md', 'LICENSE', 'CHANGELOG.md'])
    const { esm, cjs, umd, types, node, browser } = this.config.outputDirs

    const dirsToCheck = [esm, cjs, umd, types, node, browser].filter(Boolean) as string[]

    for (const dir of dirsToCheck) {
      const dirPath = path.join(this.config.projectRoot, dir)
      try {
        await fs.access(dirPath)
        files.add(dir)
      }
      catch {
        // ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡
      }
    }

    return Array.from(files)
  }

  /**
   * è¯»å– package.json
   */
  private async readPackageJson(packageJsonPath: string): Promise<any> {
    try {
      const content = await fs.readFile(packageJsonPath, 'utf-8')
      return JSON.parse(content)
    } catch (error) {
      throw new Error(`è¯»å– package.json å¤±è´¥: ${error}`)
    }
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆåŒæ­¥ï¼‰
   *
   * @param filePath - æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  private fileExistsSync(filePath: string): boolean {
    return existsSync(filePath)
  }

  /**
   * å†™å…¥ package.json
   */
  private async writePackageJson(packageJsonPath: string, packageJson: any): Promise<void> {
    try {
      const content = JSON.stringify(packageJson, null, 2)
      await fs.writeFile(packageJsonPath, content, 'utf-8')
    } catch (error) {
      throw new Error(`å†™å…¥ package.json å¤±è´¥: ${error}`)
    }
  }

  /**
   * æŒ‰ç…§æœ€ä½³å®è·µæ’åº package.json å­—æ®µ
   */
  private sortPackageJsonFields(packageJson: any): any {
    // å®šä¹‰å­—æ®µçš„ä¼˜å…ˆçº§é¡ºåº
    const fieldOrder = [
      // åŸºæœ¬ä¿¡æ¯
      'name',
      'version',
      'description',
      'keywords',
      'author',
      'license',
      'homepage',
      'repository',
      'bugs',

      // æ¨¡å—é…ç½®
      'type',
      'sideEffects',

      // å…¥å£ç‚¹
      'exports',
      'main',
      'module',
      'types',
      'unpkg',
      'jsdelivr',

      // æ–‡ä»¶é…ç½®
      'files',

      // è„šæœ¬
      'scripts',

      // ä¾èµ–
      'dependencies',
      'peerDependencies',
      'devDependencies',
      'optionalDependencies',

      // å…¶ä»–é…ç½®
      'engines',
      'os',
      'cpu',
      'publishConfig',
      'size-limit'
    ]

    const sorted: any = {}

    // æŒ‰ç…§å®šä¹‰çš„é¡ºåºæ·»åŠ å­—æ®µ
    for (const field of fieldOrder) {
      if (packageJson[field] !== undefined) {
        sorted[field] = packageJson[field]
      }
    }

    // æ·»åŠ å…¶ä»–æœªåœ¨é¡ºåºä¸­å®šä¹‰çš„å­—æ®µ
    for (const [key, value] of Object.entries(packageJson)) {
      if (!fieldOrder.includes(key)) {
        sorted[key] = value
      }
    }

    return sorted
  }

  /**
   * æ·»åŠ  CSS å¯¼å‡º
   */
  private async addCssExports(exports: Record<string, any>): Promise<void> {
    const { esm, cjs, umd } = this.config.outputDirs
    const cssFiles = new Set<string>()

    for (const dir of [esm, cjs, umd].filter(Boolean) as string[]) {
      const dirPath = path.join(this.config.projectRoot, dir)
      try {
        await fs.access(dirPath)
        await this.findCssFiles(dirPath, cssFiles, dir)
      }
      catch {
        // ç›®å½•ä¸å­˜åœ¨
      }
    }

    for (const cssFile of cssFiles) {
      const exportKey = `./${cssFile}`
      if (!exports[exportKey]) {
        exports[exportKey] = `./${cssFile}`
      }
    }
  }

  /**
   * æŸ¥æ‰¾ CSS æ–‡ä»¶
   */
  private async findCssFiles(dir: string, cssFiles: Set<string>, prefix: string): Promise<void> {
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name)

        if (entry.isDirectory()) {
          await this.findCssFiles(fullPath, cssFiles, `${prefix}/${entry.name}`)
        }
        else if (entry.name.endsWith('.css')) {
          cssFiles.add(`${prefix}/${entry.name}`)
        }
      }
    }
    catch {
      // å¿½ç•¥é”™è¯¯
    }
  }
}

/**
 * åˆ›å»º Package æ›´æ–°å™¨
 */
export function createPackageUpdater(config: PackageUpdaterConfig): PackageUpdater {
  return new PackageUpdater(config)
}

/**
 * å¿«æ·æ›´æ–°å‡½æ•°
 */
export async function updatePackageJson(config: PackageUpdaterConfig): Promise<void> {
  const updater = createPackageUpdater(config)
  await updater.update()
}

// å‘åå…¼å®¹çš„ç±»å‹åˆ«å
export type EnhancedPackageUpdaterConfig = PackageUpdaterConfig
export { PackageUpdater as EnhancedPackageUpdater }
export { createPackageUpdater as createEnhancedPackageUpdater }
